# Azure DevOps Pipeline Configuration
# Alternative to GitHub Actions for teams using Azure DevOps

trigger:
  branches:
    include:
    - main
    - test/unit-testing
  paths:
    exclude:
    - docs/*
    - README.md

pr:
  branches:
    include:
    - main

variables:
  buildConfiguration: 'Release'
  dotnetVersion: '8.0.x'
  azureSubscription: 'Azure-Service-Connection' # Configure this in Azure DevOps
  resourceGroupName: 'fintech-rg'
  location: 'eastus'
  functionAppName: 'event-payment-func'

stages:
- stage: Build
  displayName: 'Build and Test'
  jobs:
  - job: BuildJob
    displayName: 'Build Solution'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - task: UseDotNet@2
      displayName: 'Use .NET $(dotnetVersion)'
      inputs:
        version: '$(dotnetVersion)'
        packageType: 'sdk'

    - task: DotNetCoreCLI@2
      displayName: 'Restore NuGet packages'
      inputs:
        command: 'restore'
        projects: 'FintechProject.sln'

    - task: DotNetCoreCLI@2
      displayName: 'Build solution'
      inputs:
        command: 'build'
        projects: 'FintechProject.sln'
        arguments: '--configuration $(buildConfiguration) --no-restore'

    - task: DotNetCoreCLI@2
      displayName: 'Run unit tests with coverage'
      inputs:
        command: 'test'
        projects: 'test/FintechProject.Tests/FintechProject.Tests.csproj'
        arguments: '--configuration $(buildConfiguration) --no-build --logger trx --collect:"XPlat Code Coverage" --results-directory $(Agent.TempDirectory)/coverage'
        publishTestResults: true

    - task: PowerShell@2
      displayName: 'Generate coverage report and enforce 80% threshold'
      inputs:
        targetType: 'inline'
        script: |
          # Install ReportGenerator
          Write-Host "Installing ReportGenerator..."
          dotnet tool install --global dotnet-reportgenerator-globaltool --version 5.2.4
          
          # Find coverage file
          $coverageFile = Get-ChildItem -Path "$(Agent.TempDirectory)/coverage" -Filter "coverage.cobertura.xml" -Recurse | Select-Object -First 1
          
          if (-not $coverageFile) {
              Write-Host "##vso[task.logissue type=error]Coverage file not found"
              exit 1
          }
          
          Write-Host "Found coverage file: $($coverageFile.FullName)"
          
          # Generate HTML report
          Write-Host "Generating coverage report..."
          reportgenerator "-reports:$($coverageFile.FullName)" "-targetdir:$(Build.ArtifactStagingDirectory)/coverage-report" "-reporttypes:HtmlInline;Cobertura;Badges"
          
          # Parse coverage percentage
          [xml]$coverage = Get-Content $coverageFile.FullName
          $lineRate = [double]$coverage.coverage.'line-rate'
          $coveragePercent = [math]::Round($lineRate * 100, 2)
          $threshold = 80
          
          Write-Host ""
          Write-Host "========================================"
          Write-Host "üìä Code Coverage: $coveragePercent%"
          Write-Host "üéØ Required Threshold: $threshold%"
          Write-Host "========================================"
          
          # Publish coverage as build property
          Write-Host "##vso[build.addbuildtag]Coverage: $coveragePercent%"
          
          if ($coveragePercent -lt $threshold) {
              Write-Host "##vso[task.logissue type=error]Coverage $coveragePercent% is below threshold $threshold%"
              Write-Host "‚ùå Build failed: Code coverage ($coveragePercent%) is below the required threshold ($threshold%)"
              Write-Host ""
              Write-Host "üìñ To fix: Download the coverage report artifact and review uncovered code"
              exit 1
          } else {
              Write-Host "‚úÖ Coverage $coveragePercent% meets or exceeds threshold $threshold%"
          }
    
    - publish: '$(Build.ArtifactStagingDirectory)/coverage-report'
      displayName: 'Publish coverage report artifact'
      artifact: 'coverage-report'
      condition: always()

    - task: DotNetCoreCLI@2
      displayName: 'Publish Azure Functions'
      inputs:
        command: 'publish'
        publishWebProjects: false
        projects: 'src/Functions/Functions.csproj'
        arguments: '--configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)/functions'
        zipAfterPublish: true

    - publish: '$(Build.ArtifactStagingDirectory)/functions'
      displayName: 'Publish function app artifact'
      artifact: 'drop-functions'

    - publish: 'infra'
      displayName: 'Publish infrastructure artifact'
      artifact: 'drop-infra'

    # Database scripts artifact disabled - using local PostgreSQL
    # - publish: 'database'
    #   displayName: 'Publish database scripts'
    #   artifact: 'drop-database'

- stage: DeployInfrastructure
  displayName: 'Deploy Infrastructure'
  dependsOn: Build
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - deployment: DeployInfra
    displayName: 'Deploy Azure Resources'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'production'
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: drop-infra
            displayName: 'Download infrastructure artifacts'

          - task: AzureCLI@2
            displayName: 'Create Resource Group'
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az group create \
                  --name $(resourceGroupName) \
                  --location $(location)

          - task: AzureCLI@2
            displayName: 'Deploy Bicep template'
            name: bicepDeploy
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'pscore'
              scriptLocation: 'inlineScript'
              inlineScript: |
                # Deploy Bicep template
                $deployment = az deployment group create `
                  --resource-group $(resourceGroupName) `
                  --template-file $(Pipeline.Workspace)/drop-infra/main.bicep `
                  --parameters functionAppName=$(functionAppName) `
                  --query 'properties.outputs' `
                  --output json | ConvertFrom-Json
                
                # Extract outputs
                $serviceBusConnection = $deployment.serviceBusConnectionString.value
                
                # Set pipeline variable
                Write-Host "##vso[task.setvariable variable=ServiceBusConnectionString;issecret=true]$serviceBusConnection"
                Write-Host "‚úÖ Bicep deployment completed successfully"

- stage: DeployFunctionApp
  displayName: 'Deploy Function App'
  dependsOn: DeployInfrastructure
  condition: succeeded()
  jobs:
  - deployment: DeployFunction
    displayName: 'Deploy Azure Functions'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'production'
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: drop-functions
            displayName: 'Download function app artifact'

          - task: AzureFunctionApp@1
            displayName: 'Deploy to Azure Functions'
            inputs:
              azureSubscription: $(azureSubscription)
              appType: 'functionAppLinux'
              appName: $(functionAppName)
              package: '$(Pipeline.Workspace)/drop-functions/**/*.zip'
              runtimeStack: 'DOTNET-ISOLATED|8.0'
              appSettings: |
                -ServiceBusConnection "$(ServiceBusConnectionString)"
                -FUNCTIONS_WORKER_RUNTIME "dotnet-isolated"
                # PostgresConnection removed - using local database

# Database deployment stage disabled - using local PostgreSQL database
# Uncomment and configure when migrating to Azure PostgreSQL Flexible Server
#
# - stage: DeployDatabase
#   displayName: 'Deploy Database Changes'
#   dependsOn: Build
#   condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
#   jobs:
#   - job: RunMigrations
#     displayName: 'Run Database Migrations'
#     pool:
#       vmImage: 'ubuntu-latest'
#     
#     steps:
#     - download: current
#       artifact: drop-database
#       displayName: 'Download database scripts'
#
#     - task: Bash@3
#       displayName: 'Install PostgreSQL client'
#       inputs:
#         targetType: 'inline'
#         script: |
#           sudo apt-get update
#           sudo apt-get install -y postgresql-client
#
#     - task: Bash@3
#       displayName: 'Run database setup'
#       env:
#         PGPASSWORD: $(PostgresPassword)
#       inputs:
#         targetType: 'inline'
#         script: |
#           psql "$(PostgresConnectionString)" -f $(Pipeline.Workspace)/drop-database/setup.sql
#           psql "$(PostgresConnectionString)" -f $(Pipeline.Workspace)/drop-database/add_credit_cards_table.sql
#
#     - task: Bash@3
#       displayName: 'Verify database'
#       env:
#         PGPASSWORD: $(PostgresPassword)
#       inputs:
#         targetType: 'inline'
#         script: |
#           psql "$(PostgresConnectionString)" -f $(Pipeline.Workspace)/drop-database/check_database.sql
